v Create dictionary.{c,h} to store var number and var string
v Create test for dictionary + debug
v Add a dictionary for number vars and string (Only 1 dict)
v Introduce a variable struct with a union (numeric, string)
v Store vars in dict
v Expand LET with string vars
v Make LET optional
v Allow variables in expressions
v Make string expressions possible

    To simplify the code, let expressions be a compound value -> string and float
      expression_result result;
      expression(&result);
      result.value.numeric, result.value.string

    v rename exprssion -> numeric...
    v introduce expression type and function (find out type of expression)


v Add a few string functions (MID$, LEFT$, RIGHT$, LEN, SPC, TAB)
    v MID$:
      10 A$="SATURDAY MORNING"
      20 B$=MID$(A$,6,3): PRINT B$ (DAY is cut and printed out)
      30 B$=MID$(A$,1,8): PRINT B$ (same as LEFT$; SATURDAY is displayed)
      40 B$=MID$(A$,10): PRINT B$ (same as RIGHT$ or MID$(A$,10,7); MORNING is displayed)  
    v LEFT$
    v RIGHT$
    v LEN
v Expand the PRINT function
    v PRINT A$; MID$(...); "WAFFEL"
    v PRINT "STOMME" SPC(10) "BOEFEL"
    v SPC
    v TAB
    v http://www.antonis.de/qbebooks/gwbasman/
v We need string condition to compare strings in IF
v PRINT Also needs to find out expression | string_expression (expression can be var as well, string_expression also)
    Same mechanism for both -> reusable
v Refactor into core and use a registry to add statements and functions
v Rework the line saving
v GOSUB / RETURN
v FOR / NEXT / STEP
v INPUT 
v GET (inchar, outchar)
v DIM
. DATA / READ / RESTORE
. CLEAR
v END
v REM
. Optional parameters, e.g. MID$(A$, 10), MID$(A$, 1, 6)
. A% (Integer variable support)
. Rename parser.{c,h} to interpreter, rename functions
v Modular: keywords+print, numeric functions, string functions, example on expand
. printf -> registered put char (we need that for input, get anyhow)
. Try some basic programs
. prep site and docs
. release
- variables are stored at the end of the program, before the stack (or do we keep the malloc)

Architectural changes urgent
----------------------------

We have to do this first

v stack frame for gosub
v remove other stack tryouts
v __LINE_P needs to be txt_pos

  typedef line {
    uint16_t line_number;
    uint8_t length;
    char contents;
  }
  This way we can keep __line_p, and work with a one-blob program space.

v program memory is one blob: program | stack
v check the following works:
    100 FOR A=1 TO 10: FOR B=1 TO 5
    110 PRINT A*B
    120 NEXT B: NEXT A
v Refactor the folowing in the code into 1 function:
    __line = <number>;
    char *cursor = lines_get_contents( __line );
    tokenizer_char_pointer( cursor );
v Registry for tokens

v Registry for functions and statements (comamnds) (expandability)
  v POC basic dispatch
  v basic dispatch for functions with 0 to 5 parameters
  v generic array.c / array.h to store tokens (register tokens) and basic functions
  v register basic functions
      v keywords
      v op
      v functions
      v string functions
      v FOR A=1 TO 10 STEP 2
        ^ keyword
                ^ just a token without a function -> but we need to regsiter
                      ^ same for step
      v IF
  v Intercept on 3 places in parser: statememt (void), expression (numeric via factor, term) and string expression (string)
v IF 1=1 AND 2=2 THEN PRINT "OK"
  ^ Does not work, gives false, why?
  ! relation-expression resolution in factor() fixes this
v expect is bad with implicit get_sym...better to that more clearly (what do these functions do? what size effects do they have?)
    Just better understand and use consistently
v move internal functions and commands to registry format
v add functions and statements (as per above list)
. clean up dead code and commented out code
. remove all glib usage (if any) and port to avr-gcc 
. string are 256 long
