v Create dictionary.{c,h} to store var number and var string
v Create test for dictionary + debug
v Add a dictionary for number vars and string (Only 1 dict)
v Introduce a variable struct with a union (numeric, string)
v Store vars in dict
v Expand LET with string vars
v Make LET optional
v Allow variables in expressions
v Make string expressions possible

    To simplify the code, let expressions be a compound value -> string and float
      expression_result result;
      expression(&result);
      result.value.numeric, result.value.string

    v rename exprssion -> numeric...
    v introduce expression type and function (find out type of expression)


. Add a few string functions (MID$, LEFT$, RIGHT$, LEN, SPC, TAB)
    MID$:
      10 A$="SATURDAY MORNING"
      20 B$=MID$(A$,6,3): PRINT B$ (DAY is cut and printed out)
      30 B$=MID$(A$,1,8): PRINT B$ (same as LEFT$; SATURDAY is displayed)
      40 B$=MID$(A$,10): PRINT B$ (same as RIGHT$ or MID$(A$,10,7); MORNING is displayed)  
      . 
v We need string condition to compare strings in IF
v PRINT Also needs to find out expression | string_expression (expression can be var as well, string_expression also)
    Same mechanism for both -> reusable
. Rename parser.{c,h} to interpreter, rename functions
. Refactor into core and use a registry to add statements and functions
. Rework the line saving
v GOSUB / RETURN
v FOR / NEXT / STEP
. INPUT
. DIM
. DATA / READ
. CLEAR
. END
. REM
. Try some basic programs

Architectural changes urgent
----------------------------

We have to do this first

v stack frame for gosub
v remove other stack tryouts
. __LINE_P needs to be txt_pos
. program memory is one blob: program | variables | stack
. check the following works:
    100 FOR A=1 TO 10: FOR B=1 TO 5
    110 PRINT A*B
    120 NEXT A: NEXT B
. registry for functions (expandability)
. expect is bad with implicit get_sym...better to that more clearly (what do these functions do? what size effects do they have?)
